
# 1.CBV 

之前写的都是==FBV==，即用函数：

![image-20250702144152886](Drf.assets/image-20250702144152886.png)



![image-20250702144213048](Drf.assets/image-20250702144213048.png)

在==CBV==中，都是采用类，该类需要继承源码中的一个类：

![image-20250702144306229](Drf.assets/image-20250702144306229.png)

![image-20250702144316627](Drf.assets/image-20250702144316627.png)

然后写这个类：（可根据请求的方法不同来执行不同的方法）

![image-20250702144333470](Drf.assets/image-20250702144333470.png)









# 2.纯净DRF配置

**加一行：**

![image-20250702163851174](Drf.assets/image-20250702163851174.png)

**注释掉：**

![image-20250702163921893](Drf.assets/image-20250702163921893.png)

![image-20250702163931777](Drf.assets/image-20250702163931777.png)

# 3.Python中的类

**写法：**

![image-20250702173620666](Drf.assets/image-20250702173620666.png)

  ![image-20250702174132447](Drf.assets/image-20250702174132447.png)

其中里面的**getattr**， 当访问对象中不应存在的成员时会触发。

其中：**getattribute**，只要执行 对象.xxx ，它都会执行。





# 4.认证组件

## 4.1简单例子

 是用类来做认证的，最后在应用类。

![image-20250703160424545](Drf.assets/image-20250703160424545.png)

**一个最简单的认证逻辑：**

![image-20250703160715115](Drf.assets/image-20250703160715115.png)

==示例2：==

可以全局应用认证，避免一个个写。如下图：注意：全局配置的话，认证类不能写在views中，要新开文件写

![image-20250703162650120](Drf.assets/image-20250703162650120.png)



## 4.2应用

在每个视图里面写：即该视图可以认证

![image-20250703160820172](Drf.assets/image-20250703160820172.png)

## 4.3用户登录认证例子

1.2.登录时，分配token

![image-20250707175520611](Drf.assets/image-20250707175520611.png)

2.认证的类，访问非登录页面的时候，根据token去数据库查找。

![image-20250707160918820](Drf.assets/image-20250707160918820.png)

![image-20250707160926508](Drf.assets/image-20250707160926508.png)

# 5.子类约束

如果类中有这个标识（==raise NotImplementedError==），则表示继承该类时，必须写此方法

![image-20250707234320866](Drf.assets/image-20250707234320866.png)

 # 6 .权限组件

## 1.编写认证类

![image-20250707235429440](Drf.assets/image-20250707235429440.png)

## 2.应用（全局或者单独组件）

![image-20250707235522133](Drf.assets/image-20250707235522133.png)

全局：

![image-20250707235635479](Drf.assets/image-20250707235635479.png)

## 3.错误提示

当访问失败时，需要进行错误提示。写法如下，里面有一个静态变量（message）：

![image-20250708000140798](Drf.assets/image-20250708000140798.png)



## 4.修改执行

当有多个权限时，需要每个都通过才行，如果有一个不通过，则停止。

==现在可以做一下修改，使得满足一个条件就可以通过。==

修改逻辑：阅读源码，发现是APIView中的check_permission来判断权限。

所以只需要在权限类中重新定义一下check_permission函数即可，因为先在父类中找，没找到再去子类找。

![image-20250708230544038](Drf.assets/image-20250708230544038.png)

## 5.认证和权限都是在中间件之后执行的，晚很多。





# 7.限流组件

作用：开发中，某个接口不想让用户访问过于频繁。

![image-20250708234710101](Drf.assets/image-20250708234710101.png)

## 1.限制逻辑

![image-20250708234747316](Drf.assets/image-20250708234747316.png)

## 2.快速编写应用

1.get_cache_key是获取唯一标识，scop是拼接字符串一部分（可以自定义），THROTTLE_RATES是限制的访问频率，cache是缓存。![image-20250709002248263](Drf.assets/image-20250709002248263.png)

2.配置缓存，在settings文件中配置。

![image-20250709002542638](Drf.assets/image-20250709002542638.png)

3.在任意视图类中应用（也可全局应用，同上）。

![image-20250709002634495](Drf.assets/image-20250709002634495.png)

# 8.版本

## 1.基于get参数

![image-20250711004012993](Drf.assets/image-20250711004012993.png)

在url中加入？version=xxx,然后就可以在request.version中读取版本。

# 9.解析器

![image-20250711010918016](Drf.assets/image-20250711010918016.png)

解析请求者发送过来的数据，解析成我们想要的数据。

一般指的是对post请求的请求体中的数据进行解析。

步骤：1.读取请求头。

​             2.根据请求头解析数据。（先根据请求头获取解析器，在解析数据赋值给reques.data）

比如：<img src="Drf.assets/image-20250711011602726.png" alt="image-20250711011602726" style="zoom:25%;" />他对应的请求体是<img src="Drf.assets/image-20250711011633258.png" alt="image-20250711011633258" style="zoom:25%;" />

   <img src="Drf.assets/image-20250711011644544.png" alt="image-20250711011644544" style="zoom:25%;" />对应的请求体是<img src="Drf.assets/image-20250711011700928.png" alt="image-20250711011700928" style="zoom:25%;" />

# 10.序列化器

作用：1.序列化  2.数据校验

![image-20250711012350719](Drf.assets/image-20250711012350719.png)
